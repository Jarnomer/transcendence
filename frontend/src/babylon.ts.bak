import {
  Engine, Scene,
  MeshBuilder, StandardMaterial,
  FreeCamera, HemisphericLight,
  Color3, Vector3
} from 'babylonjs';

export interface Player {
  id: string;
  y: number;
  score: number;
  mesh?: any;
}

export interface Ball {
  x: number;
  y: number;
  dx: number;
  dy: number;
  mesh?: any;
}

export interface GameState {
  canvas: HTMLCanvasElement | null;
  engine?: Engine;
  scene?: Scene;
  paddleWidth: number;
  paddleHeight: number;
  ballSize: number;
  paddleSpeed: number;
  ballSpeed: number;
  players: Record<string, Player>;
  ball: Ball;
  countdown: number;
  countdownInProgress: boolean;
}

export class BabylonGame {
  private gameState: GameState;
  private keysPressed: Record<string, boolean> = {};
  private ws: WebSocket | null = null;

  constructor() {
    this.gameState = {
      canvas: null,
      paddleWidth: 0.5,
      paddleHeight: 2,
      ballSize: 0.5,
      paddleSpeed: 0.1,
      ballSpeed: 0.05,
      players: {
        player1: { id: "player1", y: 0, score: 0 },
        player2: { id: "player2", y: 0, score: 0 }
      },
      ball: { x: 0, y: 0, dx: 0.05, dy: 0.05 },
      countdown: 3,
      countdownInProgress: false
    };

    this.setupKeyboardListeners();
  }

  private setupKeyboardListeners() {
    document.addEventListener("keydown", (e) => {
      this.keysPressed[e.key] = true;
    });

    document.addEventListener("keyup", (e) => {
      this.keysPressed[e.key] = false;
    });
  }

  public initialize(canvas: HTMLCanvasElement, websocket: WebSocket) {
    this.gameState.canvas = canvas;
    this.ws = websocket;

    const engine = new Engine(canvas, true);
    const scene = new Scene(engine);

    // Camera setup
    const camera = new FreeCamera("camera", new Vector3(0, 5, -10), scene);
    camera.setTarget(Vector3.Zero());
    camera.attachControl(canvas, true);

    // Light setup
    const light = new HemisphericLight("light", new Vector3(0, 1, 0), scene);
    light.intensity = 0.7;

    // Material setup
    const paddleMaterial = new StandardMaterial("paddleMat", scene);
    paddleMaterial.diffuseColor = Color3.White();

    // Create meshes
    this.gameState.players.player1.mesh = MeshBuilder.CreateBox("paddle1", {
      height: 2, width: 0.5, depth: 0.5
    }, scene);
    this.gameState.players.player2.mesh = MeshBuilder.CreateBox("paddle2", {
      height: 2, width: 0.5, depth: 0.5
    }, scene);
    this.gameState.ball.mesh = MeshBuilder.CreateSphere("ball", {
      diameter: 0.5
    }, scene);

    // Position meshes
    this.gameState.players.player1.mesh.position.x = -4;
    this.gameState.players.player2.mesh.position.x = 4;
    this.gameState.ball.mesh.position.x = 0;
    this.gameState.ball.mesh.position.y = 0;
    
    // Apply materials
    this.gameState.players.player1.mesh.material = paddleMaterial;
    this.gameState.players.player2.mesh.material = paddleMaterial;
    this.gameState.ball.mesh.material = paddleMaterial;

    // Store engine and scene
    this.gameState.engine = engine;
    this.gameState.scene = scene;

    // Start render loop
    engine.runRenderLoop(() => {
      scene.render();
    });

    // Handle resize
    window.addEventListener("resize", () => {
      engine.resize();
    });

    // Start game loop
    this.gameLoop();
  }

  private updateScene() {
    if (this.gameState.countdownInProgress) return;

    this.gameState.ball.mesh.position.x += this.gameState.ball.dx;
    this.gameState.ball.mesh.position.y += this.gameState.ball.dy;

    if (this.ws?.readyState === WebSocket.OPEN) {
      if (this.keysPressed["w"]) {
        this.gameState.players.player1.mesh.position.y += this.gameState.paddleSpeed;
        this.ws.send(JSON.stringify({ type: "move", playerId: "player1", move: "up" }));
      }
      if (this.keysPressed["s"]) {
        this.gameState.players.player1.mesh.position.y -= this.gameState.paddleSpeed;
        this.ws.send(JSON.stringify({ type: "move", playerId: "player1", move: "down" }));
      }
      if (this.keysPressed["ArrowUp"]) {
        this.gameState.players.player2.mesh.position.y += this.gameState.paddleSpeed;
        this.ws.send(JSON.stringify({ type: "move", playerId: "player2", move: "up" }));
      }
      if (this.keysPressed["ArrowDown"]) {
        this.gameState.players.player2.mesh.position.y -= this.gameState.paddleSpeed;
        this.ws.send(JSON.stringify({ type: "move", playerId: "player2", move: "down" }));
      }
    }
  }

  private gameLoop = () => {
    this.updateScene();
    requestAnimationFrame(this.gameLoop);
  };

  public dispose() {
    this.gameState.engine?.dispose();
    this.gameState.scene?.dispose();
    this.ws = null;
  }

  public updateScores(player1Score: number, player2Score: number) {
    this.gameState.players.player1.score = player1Score;
    this.gameState.players.player2.score = player2Score;
  }
}

// import {
//   Engine, Scene,
//   MeshBuilder, StandardMaterial,
//   FreeCamera, HemisphericLight,
//   Color3, Vector3
// } from 'babylonjs';

// type Player = {
//   id: string;
//   y: number;
//   score: number;
//   mesh?: any;
// };

// type Ball = {
//   x: number;
//   y: number;
//   dx: number;
//   dy: number;
//   mesh?: any;
// };

// export type GameState = {
//   canvas: HTMLCanvasElement | null;
//   engine?: Engine;
//   scene?: Scene;
//   paddleWidth: number;
//   paddleHeight: number;
//   ballSize: number;
//   paddleSpeed: number;
//   ballSpeed: number;
//   players: Record<string, Player>;
//   ball: Ball;
//   countdown: number;
//   countdownInProgress: boolean;
// };

// export function initGame(gameState: GameState) {
//   const canvas = document.getElementById("gameCanvas") as HTMLCanvasElement;
//   if (!canvas) {
//     console.error("Canvas not found!");
//     return;
//   }

//   canvas.width = 800;
//   canvas.height = 400;

//   const engine = new Engine(canvas, true);
//   const scene = new Scene(engine);
//   const camera = new FreeCamera("camera", new Vector3(0, 5, -10), scene);
//   const light = new HemisphericLight("light", new Vector3(0, 1, 0), scene);
//   const paddleMaterial = new StandardMaterial("paddleMat", scene);

//   const gameStateInit = {
//     canvas,
//     engine,
//     scene,

//     paddleWidth: 0.5,
//     paddleHeight: 2,
//     ballSize: 0.5,
//     paddleSpeed: 0.1,
//     ballSpeed: 0.05,

//     players: {
//       player1: {
//         id: "player1",
//         y: 0,
//         score: 0,
//         mesh: MeshBuilder.CreateBox("paddle1", {
//           height: 2, width: 0.5, depth: 0.5
//         }, scene)
//       },
//       player2: {
//         id: "player2",
//         y: 0,
//         score: 0,
//         mesh: MeshBuilder.CreateBox("paddle2", {
//           height: 2, width: 0.5, depth: 0.5
//         }, scene)
//       }
//     },

//     ball: {
//       x: 0,
//       y: 0,
//       dx: 0.05,
//       dy: 0.05,
//       mesh: MeshBuilder.CreateSphere("ball", {
//         diameter: 0.5
//       }, scene)
//     },

//     countdown: 3,
//     countdownInProgress: false,
//   };

//   camera.setTarget(Vector3.Zero());
//   camera.attachControl(canvas, true);
//   light.intensity = 0.7;
//   paddleMaterial.diffuseColor = Color3.White();
//   gameStateInit.players.player1.mesh.position.x = -4;
//   gameStateInit.players.player2.mesh.position.x = 4;
//   gameStateInit.players.player1.mesh.material = paddleMaterial;
//   gameStateInit.players.player2.mesh.material = paddleMaterial;
//   gameStateInit.ball.mesh.material = paddleMaterial;

//   Object.assign(gameState, gameStateInit);

//   if (!gameState.players.player1.mesh || !gameState.players.player2.mesh || !gameState.ball.mesh) {
//     console.error("Game meshes not properly initialized");
//     return;
//   }

//   console.log("Player 1 mesh:", gameState.players.player1.mesh);
//   console.log("Player 2 mesh:", gameState.players.player2.mesh);
//   console.log("Ball mesh:", gameState.ball.mesh);

//   engine.runRenderLoop(() => {
//     scene.render();
//   });

//   window.addEventListener("resize", () => {
//     engine.resize();
//   });

//   console.log("Game initialized successfully.");
// }

// const keysPressed: Record<string, boolean> = {};

// document.addEventListener("keydown", (e) => {
//   keysPressed[e.key] = true;
// });

// document.addEventListener("keyup", (e) => {
//   keysPressed[e.key] = false;
// });

// function updateScene(gameState: GameState, ws: WebSocket) {
//   if (gameState.countdownInProgress) return;

//   gameState.ball.mesh.position.x += gameState.ball.dx;
//   gameState.ball.mesh.position.y += gameState.ball.dy;

//   if (ws.readyState === WebSocket.OPEN) {
//     if (keysPressed["w"]) {
//       gameState.players.player1.mesh.position.y += gameState.paddleSpeed;
//       ws.send(JSON.stringify({ type: "move", playerId: "player1", move: "up" }));
//     }
//     if (keysPressed["s"]) {
//       gameState.players.player1.mesh.position.y -= gameState.paddleSpeed;
//       ws.send(JSON.stringify({ type: "move", playerId: "player1", move: "down" }));
//     }
//     if (keysPressed["ArrowUp"]) {
//       gameState.players.player2.mesh.position.y += gameState.paddleSpeed;
//       ws.send(JSON.stringify({ type: "move", playerId: "player2", move: "up" }));
//     }
//     if (keysPressed["ArrowDown"]) {
//       gameState.players.player2.mesh.position.y -= gameState.paddleSpeed;
//       ws.send(JSON.stringify({ type: "move", playerId: "player2", move: "down" }));
//     }
//   }
// }

// export function gameLoop(gameState: GameState, ws: WebSocket) {
//   if (!gameState.scene || !gameState.engine) {
//     console.error("Game loop stopped: No scene or engine found.");
//     return;
//   }
//   updateScene(gameState, ws);
//   requestAnimationFrame(() => gameLoop(gameState, ws));
// }
